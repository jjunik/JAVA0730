public class 클래스명<T> {

}
public interface 인터페이스명 <T>{

}

TreeSet
- 이진탐색트리 중에서도 성능을 향상시킨 레드블랙트리로 구현되어있다
- 레드 블랙트리는 부모 노드보다 작은 값을 가지는 노드는 왼쪽, 
큰 값을 가지는 노드는 오른쪽으로 배치한다
- 데이터의 추가나 삭제시 트리가 한쪽으로 치우쳐지지 않도록 균형을 맞춰준다.

Map
- List, Set과 달리 Map인터페이스가 별도로 존재하며 데이터를 List계열 컬렉션과 다르게 처리
- 데이터를 Key와 value로 구분하여 저장하는 key-value 방식을 사용한다.
- index는 없지만 key를 통해서 값을 검색하기 때문에 많은 양의 데이터를 
조회하는 데 있어 매우 뛰어난 성능을 발휘한다.

HashMap
- map을 구현하고 있는 자식 클래스에서 가장 많이 사용하는 구현체이다.

----------------------------------------------------------------------------
generic 사용 시 주의사항
1. 제네릭 타입의 객체는 생성할 수 없다.
- 제네릭 타입 자체로 객체를 생성하는것은 불가능
ex) T t = new T(); -> X

2. static 멤버에 제네릭 타입이 올 수 없음
- static 멤버는 클래스가 동일하게 공유하는 변수로서 제네릭 객체가 생성되기도 전에 
이미 자료타입이 정해져 있어야 하기 때문이다

2-1 static 메서드의 반환타입으로 사용이 불가능
public static T getAge(int n){ --> X
}

2-2 static 메서드의 매개변수 타입으로 사용이 불가능
public static void setAge(T age){ --> X
}

3. 제네릭으로 배열 선언 시 주의할 점
- 기본적으로 제네릭 클래스 자체를 배열로 만들 수 는 없다.
Student<Integer>[] arr1 = new Student<>[10]; -> X

제네릭 타입에 클래스가 들어온다는 것은, 
클래스 끼리 상속을 통해 관계를 맺는	다형성이 그대로 적용되지 않을까?

중첩타입 파라미터
- 제네릭 객체를 제네릭 타입 파라미터로 받는 형식으로 표현할수있다.
- ArrayList 자체도 하나의 타입으로서 제네릭 타입 파라미터가 될 수 있기 때문에 
중첩 형식으로 사용할 수 있다.

제네릭 인터페이스
- 인터페이스를 구현(implements) 한 클래스에서도 오버라이딩한 메서드를 제네릭 타입에 맞춰서
똑같이 구현해야 한다.

제네릭메서드
메서드에만 적용되는 제네릭 타입

제네릭타입 범위 한정하기
- 제네릭에 타입을 지정해줌으로서 클래스의 타입을 컴파일시에 정하여 타입 예외에 대한
안정성을 확보하는것은 좋지만 문제는 너무 자유롭다는 점이다.

타입 한정 키워드 extends
<T extends 제한타입>

extends 뒤에 올 타입은 일반클래스, 추상클래스, 인터페이스 모두 가능하다.

다중타입한정
- 만일 2개 이상의 타입을 동시에 구현한 경우 타입 제한을 하고싶다면 & 연산자를 사용한다
- 해당 인터페이스들을 동시에 구현한 클래스가 제네릭 타입에 대상이 되게 한다.
- 단, 자바에서는 다중 상속을 지원하지 않기 때문에 클래스로는 다중 extends는 불가능하고 
오로지 인터페이스로만이 가능하다

제네릭의 형변환
- 제네릭 형변환
배열과 같은 일반적인 변수 타입과 달리 제네릭 서브 타입간에는 형변환이 불가능하다.
자연스럽게 다형성이 적용될 것이라고 생각할 수 있지만,
 실상 제네릭은 전달받은 타입으로만 캐스팅이 가능하다
 
제네릭 타입은 상하관계가 없다
제네릭 타입변수끼리는 아무리 상속관계에 놓인다 한들 형변환이 불가능하다.

제네릭 와일드카드
제네릭 간의 형변환을 성립되게 하기위해서는 제네릭에서 제공하는 문법을 이용해야 한다.

<?> : Unbounded WildCards(제한없음)
- 타임 파라미터를 대치하는 구체적인 타입으로 모든 클래스나 인터페이스 타입이 올수있다

<? extends 상위타입> : Upper Bounded WildCards(상위 클래스 제한)
- 타입 파라미터를 대치하는 구체적인 타입으로 상위 타입이나, 상위 타입의 하위 타입만 올 수있다.

<? super 하위타입> : Lower Bounded WildCards(하위클래스 제한)
- 타입 파라미터를 대치하는 구체적인 타입으로 하위 타입이나 하위타입의 상위 타입만 올 수있다.

